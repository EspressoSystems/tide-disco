<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Tide Disco is a web server framework with built-in discoverability support for Tide"><title>tide_disco - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tide_disco" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tide_disco/index.html">tide_disco</a><span class="version">0.9.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">tide_disco</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/tide_disco/lib.rs.html#7-704">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><em>Tide Disco is a web server framework with built-in discoverability support for
<a href="https://github.com/http-rs/tide">Tide</a></em></p>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2>
<p>We say a system is <em>discoverable</em> if guesses and mistakes regarding usage are rewarded with
relevant documentation and assistance at producing correct requests. To offer this capability in
a practical way, it is helpful to specify the API in data files, rather than code, so that all
relevant text can be edited in one concise readable specification.</p>
<p>Tide Disco leverages TOML to specify</p>
<ul>
<li>Routes with typed parameters</li>
<li>Route documentation</li>
<li>Route error messages</li>
<li>General documentation</li>
</ul>
<h3 id="goals"><a class="doc-anchor" href="#goals">§</a>Goals</h3>
<ul>
<li>Context-sensitive help</li>
<li>Spelling suggestions</li>
<li>Reference documentation assembled from route documentation</li>
<li>Forms and other user interfaces to aid in the construction of correct inputs</li>
<li>Localization</li>
<li>Novice and expert help</li>
<li>Flexible route parsing, e.g. named parameters rather than positional parameters</li>
<li>API fuzz testing automation based on parameter types</li>
</ul>
<h3 id="future-work"><a class="doc-anchor" href="#future-work">§</a>Future work</h3>
<ul>
<li>WebSocket support</li>
<li>Runtime control over logging</li>
</ul>
<h2 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting started</h2>
<p>A Tide Disco app is composed of one or more <em>API modules</em>. An API module consists of a TOML
specification and a set of route handlers – Rust functions – to provide the behavior of the
routes defined in the TOML. You can learn the format of the TOML file by looking at the examples
in this crate. Once you have it, you can load it into an API description using <a href="api/struct.Api.html#method.new" title="associated function tide_disco::api::Api::new">Api::new</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tide_disco::Api;
<span class="kw">use </span>tide_disco::error::ServerError;
<span class="kw">use </span>vbs::version::StaticVersion;

<span class="kw">type </span>State = ();
<span class="kw">type </span>Error = ServerError;
<span class="kw">type </span>StaticVer01 = StaticVersion&lt;<span class="number">0</span>, <span class="number">1</span>&gt;;

<span class="kw">let </span>spec: toml::Value = toml::from_str(
    std::str::from_utf8(<span class="kw-2">&amp;</span>std::fs::read(<span class="string">"/path/to/api.toml"</span>).unwrap()).unwrap(),
).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>api = Api::&lt;State, Error, StaticVer01&gt;::new(spec)<span class="question-mark">?</span>;</code></pre></div>
<p>Once you have an <a href="api/struct.Api.html" title="struct tide_disco::api::Api">Api</a>, you can define route handlers for any routes in your TOML specification.
Suppose you have the following route definition:</p>
<div class="example-wrap"><pre class="language-toml"><code>[route.hello]
PATH = [&quot;hello&quot;]
METHOD = &quot;GET&quot;
</code></pre></div>
<p>Register a handler for it like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures::FutureExt;

api.get(<span class="string">"hello"</span>, |req, state| <span class="kw">async move </span>{ <span class="prelude-val">Ok</span>(<span class="string">"Hello, world!"</span>) }.boxed())<span class="question-mark">?</span>;</code></pre></div>
<p>See <a href="api/struct.Api.html" title="struct tide_disco::api::Api">the API reference</a> for more details on what you can do to create an <a href="api/struct.Api.html" title="struct tide_disco::api::Api">Api</a>.</p>
<p>Once you have registered all of your route handlers, you need to register your <a href="api/struct.Api.html" title="struct tide_disco::api::Api">Api</a> module with
an <a href="app/struct.App.html" title="struct tide_disco::app::App">App</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tide_disco::App;
<span class="kw">use </span>vbs::version::{StaticVersion, StaticVersionType};

<span class="kw">type </span>StaticVer01 = StaticVersion&lt;<span class="number">0</span>, <span class="number">1</span>&gt;;

<span class="kw">let </span><span class="kw-2">mut </span>app = App::&lt;State, Error&gt;::with_state(());
app.register_module(<span class="string">"api"</span>, api);
app.serve(<span class="string">"http://localhost:8080"</span>, StaticVer01::instance()).<span class="kw">await</span>;</code></pre></div>
<p>Then you can use your application:</p>
<div class="example-wrap"><pre class="language-text"><code>curl http://localhost:8080/api/hello
</code></pre></div><h2 id="boxed-futures"><a class="doc-anchor" href="#boxed-futures">§</a>Boxed futures</h2>
<p>As a web server framework, Tide Disco naturally includes many interfaces that take functions as
arguments. For example, route handlers are registered by passing a handler function to an <a href="api/struct.Api.html" title="struct tide_disco::api::Api">Api</a>
object. Also naturally, many of these function parameters are async, which of course just means
that they are regular functions returning some type <code>F</code> that implements the
<a href="https://doc.rust-lang.org/1.81.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a> trait. This is all perfectly usual, but throughout the interfaces in
this crate, you may notice something that is a bit unusual: many of these functions are required
to return not just any <a href="https://doc.rust-lang.org/1.81.0/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>, but a
<a href="futures::future::BoxFuture">BoxFuture</a>. This is due to a limitation that currently exists
in the Rust compiler.</p>
<p>The problem arises with functions where the returned future is not <code>'static</code>, but rather borrows
from the function parameters. Consider the following route definition, for example:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">type </span>State = RwLock&lt;u64&gt;;
<span class="kw">type </span>Error = ();

api.at(<span class="string">"someroute"</span>, |_req, state: <span class="kw-2">&amp;</span>State| <span class="kw">async </span>{
    <span class="prelude-val">Ok</span>(<span class="kw-2">*</span>state.read().<span class="kw">await</span>)
})</code></pre></div>
<p>The <code>async</code> block in the route handler uses the <code>state</code> reference, so the resulting future is
only valid for as long as the reference <code>state</code> is valid. We could write the signature of the
route handler like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures::Future;
<span class="kw">use </span>tide_disco::RequestParams;

<span class="kw">type </span>State = async_std::sync::RwLock&lt;u64&gt;;
<span class="kw">type </span>Error = ();

<span class="kw">fn </span>handler&lt;<span class="lifetime">'a</span>&gt;(
    req: RequestParams,
    state: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>State,
) -&gt; <span class="kw">impl </span><span class="lifetime">'a </span>+ Future&lt;Output = <span class="prelude-ty">Result</span>&lt;u64, Error&gt;&gt; {
    <span class="comment">// ...
</span>}</code></pre></div>
<p>Notice how we explicitly constrain the future type by the lifetime <code>'a</code> using <code>impl</code> syntax.
Unfortunately, while we can write a function signature like this, we cannot write a type bound
that uses the <a href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a> trait and represents the equivalent function signature. This is a problem,
since interfaces like <a href="api/struct.Api.html#method.at" title="method tide_disco::api::Api::at">at</a> would like to consume any function-like object which
implements <a href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>, not just static function pointers. Here is what we would <em>like</em> to write:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;State, Error, VER: StaticVersionType&gt; Api&lt;State, Error, VER&gt; {
    <span class="kw">pub fn </span>at&lt;F, T&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, route: <span class="kw-2">&amp;</span>str, handler: F)
    <span class="kw">where
        </span>F: <span class="kw">for</span>&lt;<span class="lifetime">'a</span>&gt; Fn&lt;(RequestParams, <span class="kw-2">&amp;</span><span class="lifetime">'a </span>State)&gt;,
        <span class="kw">for</span>&lt;<span class="lifetime">'a</span>&gt; &lt;F <span class="kw">as </span>Fn&lt;(RequestParams, <span class="kw-2">&amp;</span><span class="lifetime">'a </span>State)&gt;&gt;::Output:
            <span class="lifetime">'a </span>+ Future&lt;Output = <span class="prelude-ty">Result</span>&lt;T, Error&gt;&gt;,
    {...}
}</code></pre></div>
<p>Here we are using a higher-rank trait bound on the associated type <code>Output</code> of the <a href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>
implementation for <code>F</code> in order to constrain the future by the lifetime <code>'a</code>, which is the
lifetime of the <code>State</code> reference. It is actually possible to write this function signature
today in unstable Rust (using the raw <a href="https://doc.rust-lang.org/1.81.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a> trait as a bound is unstable), but even then, no
associated type will be able to implement the HRTB due to a bug in the compiler. This limitation
is described in detail in
<a href="https://users.rust-lang.org/t/trait-bounds-for-fn-returning-a-future-that-forwards-the-lifetime-of-the-fn-s-arguments/63275/7">this post</a>.</p>
<p>As a workaround until this is fixed, we require the function <code>F</code> to return a concrete future
type with an explicit lifetime parameter: <a href="futures::future::BoxFuture">BoxFuture</a>. This allows
us to specify the lifetime constraint within the HRTB on <code>F</code> itself, rather than resorting to a
separate HRTB on the associated type <code>Output</code> in order to be able to name the return type of
<code>F</code>. Here is the actual (partial) signature of <a href="api/struct.Api.html#method.at" title="method tide_disco::api::Api::at">at</a>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;State, Error, VER: StaticVersionType&gt; Api&lt;State, Error, VER&gt; {
    <span class="kw">pub fn </span>at&lt;F, T&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, route: <span class="kw-2">&amp;</span>str, handler: F)
    <span class="kw">where
        </span>F: <span class="kw">for</span>&lt;<span class="lifetime">'a</span>&gt; Fn(RequestParams, <span class="kw-2">&amp;</span><span class="lifetime">'a </span>State) -&gt; BoxFuture&lt;<span class="lifetime">'a</span>, <span class="prelude-ty">Result</span>&lt;T, Error&gt;&gt;,
    {...}
}</code></pre></div>
<p>What this means for your code is that functions you pass to the Tide Disco framework must return
a boxed future. When passing a closure, you can simply add <code>.boxed()</code> to your <code>async</code> block,
like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::sync::RwLock;
<span class="kw">use </span>futures::FutureExt;
<span class="kw">use </span>tide_disco::Api;
<span class="kw">use </span>vbs::version::StaticVersion;

<span class="kw">type </span>State = RwLock&lt;u64&gt;;
<span class="kw">type </span>Error = ();

<span class="kw">type </span>StaticVer01 = StaticVersion&lt;<span class="number">0</span>, <span class="number">1</span>&gt;;

<span class="kw">fn </span>define_routes(api: <span class="kw-2">&amp;mut </span>Api&lt;State, Error, StaticVer01&gt;) {
    api.at(<span class="string">"someroute"</span>, |_req, state: <span class="kw-2">&amp;</span>State| <span class="kw">async </span>{
        <span class="prelude-val">Ok</span>(<span class="kw-2">*</span>state.read().<span class="kw">await</span>)
    }.boxed());
}</code></pre></div>
<p>This also means that you cannot pass the name of an <code>async fn</code> directly, since <code>async</code> functions
declared with the <code>async fn</code> syntax do not return a boxed future. Instead, you can wrap the
function in a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_std::sync::RwLock;
<span class="kw">use </span>futures::FutureExt;
<span class="kw">use </span>tide_disco::{Api, RequestParams};
<span class="kw">use </span>vbs::version::StaticVersion;

<span class="kw">type </span>State = RwLock&lt;u64&gt;;
<span class="kw">type </span>Error = ();
<span class="kw">type </span>StaticVer01 = StaticVersion&lt;<span class="number">0</span>, <span class="number">1</span>&gt;;

<span class="kw">async fn </span>handler(_req: RequestParams, state: <span class="kw-2">&amp;</span>State) -&gt; <span class="prelude-ty">Result</span>&lt;u64, Error&gt; {
    <span class="prelude-val">Ok</span>(<span class="kw-2">*</span>state.read().<span class="kw">await</span>)
}

<span class="kw">fn </span>register(api: <span class="kw-2">&amp;mut </span>Api&lt;State, Error, StaticVer01&gt;) {
    api.at(<span class="string">"someroute"</span>, |req, state: <span class="kw-2">&amp;</span>State| handler(req, state).boxed());
}</code></pre></div>
<p>In the future, we may create an attribute macro which can rewrite an <code>async fn</code> to return a
boxed future directly, like</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[boxed_future]
</span><span class="kw">async fn </span>handler(_req: RequestParams, state: <span class="kw-2">&amp;</span>State) -&gt; <span class="prelude-ty">Result</span>&lt;u64, Error&gt; {
    <span class="prelude-val">Ok</span>(<span class="kw-2">*</span>state.read().<span class="kw">await</span>)
}</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Api"><code>pub use api::<a class="struct" href="api/struct.Api.html" title="struct tide_disco::api::Api">Api</a>;</code></div></li><li><div class="item-name" id="reexport.App"><code>pub use app::<a class="struct" href="app/struct.App.html" title="struct tide_disco::app::App">App</a>;</code></div></li><li><div class="item-name" id="reexport.Error"><code>pub use error::<a class="trait" href="error/trait.Error.html" title="trait tide_disco::error::Error">Error</a>;</code></div></li><li><div class="item-name" id="reexport.Method"><code>pub use method::<a class="enum" href="method/enum.Method.html" title="enum tide_disco::method::Method">Method</a>;</code></div></li><li><div class="item-name" id="reexport.RequestError"><code>pub use request::<a class="enum" href="request/enum.RequestError.html" title="enum tide_disco::request::RequestError">RequestError</a>;</code></div></li><li><div class="item-name" id="reexport.RequestParam"><code>pub use request::<a class="struct" href="request/struct.RequestParam.html" title="struct tide_disco::request::RequestParam">RequestParam</a>;</code></div></li><li><div class="item-name" id="reexport.RequestParamType"><code>pub use request::<a class="enum" href="request/enum.RequestParamType.html" title="enum tide_disco::request::RequestParamType">RequestParamType</a>;</code></div></li><li><div class="item-name" id="reexport.RequestParamValue"><code>pub use request::<a class="enum" href="request/enum.RequestParamValue.html" title="enum tide_disco::request::RequestParamValue">RequestParamValue</a>;</code></div></li><li><div class="item-name" id="reexport.RequestParams"><code>pub use request::<a class="struct" href="request/struct.RequestParams.html" title="struct tide_disco::request::RequestParams">RequestParams</a>;</code></div></li><li><div class="item-name" id="reexport.StatusCode"><code>pub use status::<a class="struct" href="status/struct.StatusCode.html" title="struct tide_disco::status::StatusCode">StatusCode</a>;</code></div></li><li><div class="item-name" id="reexport.http"><code>pub use tide::http;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="api/index.html" title="mod tide_disco::api">api</a></div></li><li><div class="item-name"><a class="mod" href="app/index.html" title="mod tide_disco::app">app</a></div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod tide_disco::error">error</a></div></li><li><div class="item-name"><a class="mod" href="healthcheck/index.html" title="mod tide_disco::healthcheck">healthcheck</a></div></li><li><div class="item-name"><a class="mod" href="listener/index.html" title="mod tide_disco::listener">listener</a></div></li><li><div class="item-name"><a class="mod" href="method/index.html" title="mod tide_disco::method">method</a></div><div class="desc docblock-short">Interfaces for methods of accessing to state.</div></li><li><div class="item-name"><a class="mod" href="metrics/index.html" title="mod tide_disco::metrics">metrics</a></div><div class="desc docblock-short">Support for routes using the Prometheus metrics format.</div></li><li><div class="item-name"><a class="mod" href="request/index.html" title="mod tide_disco::request">request</a></div></li><li><div class="item-name"><a class="mod" href="socket/index.html" title="mod tide_disco::socket">socket</a></div><div class="desc docblock-short">An interface for asynchronous communication with clients, using WebSockets.</div></li><li><div class="item-name"><a class="mod" href="status/index.html" title="mod tide_disco::status">status</a></div></li><li><div class="item-name"><a class="mod" href="testing/index.html" title="mod tide_disco::testing">testing</a></div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.join.html" title="macro tide_disco::join">join</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DiscoArgs.html" title="struct tide_disco::DiscoArgs">DiscoArgs</a></div></li><li><div class="item-name"><a class="struct" href="struct.ServerState.html" title="struct tide_disco::ServerState">ServerState</a></div></li><li><div class="item-name"><a class="struct" href="struct.Url.html" title="struct tide_disco::Url">Url</a></div><div class="desc docblock-short">A parsed URL record.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DiscoKey.html" title="enum tide_disco::DiscoKey">DiscoKey</a></div><div class="desc docblock-short">Configuration keys for Tide Disco settings</div></li><li><div class="item-name"><a class="enum" href="enum.HealthStatus.html" title="enum tide_disco::HealthStatus">HealthStatus</a></div></li><li><div class="item-name"><a class="enum" href="enum.UrlSegment.html" title="enum tide_disco::UrlSegment">UrlSegment</a></div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.SERVER_STARTUP_RETRIES.html" title="constant tide_disco::SERVER_STARTUP_RETRIES">SERVER_STARTUP_RETRIES</a></div><div class="desc docblock-short">Number of times to poll before failing</div></li><li><div class="item-name"><a class="constant" href="constant.SERVER_STARTUP_SLEEP_MS.html" title="constant tide_disco::SERVER_STARTUP_SLEEP_MS">SERVER_STARTUP_SLEEP_MS</a></div><div class="desc docblock-short">Number of milliseconds to sleep between attempts</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.app_api_path.html" title="fn tide_disco::app_api_path">app_api_path</a></div></li><li><div class="item-name"><a class="fn" href="fn.check_api.html" title="fn tide_disco::check_api">check_api</a></div><div class="desc docblock-short">Check api.toml for schema compliance errors</div></li><li><div class="item-name"><a class="fn" href="fn.compose_config_path.html" title="fn tide_disco::compose_config_path">compose_config_path</a></div><div class="desc docblock-short">Compose the path to the application’s configuration file</div></li><li><div class="item-name"><a class="fn" href="fn.compose_settings.html" title="fn tide_disco::compose_settings">compose_settings</a></div><div class="desc docblock-short">Get the application configuration</div></li><li><div class="item-name"><a class="fn" href="fn.configure_router.html" title="fn tide_disco::configure_router">configure_router</a></div><div class="desc docblock-short">Add routes from api.toml to the routefinder instance in tide-disco</div></li><li><div class="item-name"><a class="fn" href="fn.get_api_path.html" title="fn tide_disco::get_api_path">get_api_path</a></div><div class="desc docblock-short">Get the path to <code>api.toml</code></div></li><li><div class="item-name"><a class="fn" href="fn.healthcheck.html" title="fn tide_disco::healthcheck">healthcheck</a></div><div class="desc docblock-short">Return a JSON expression with status 200 indicating the server
is up and running. The JSON expression is normally
{“status”: “Available”}
When the server is running but unable to process requests
normally, a response with status 503 and payload {“status”:
“unavailable”} should be added.</div></li><li><div class="item-name"><a class="fn" href="fn.init_logging.html" title="fn tide_disco::init_logging">init_logging</a></div></li><li><div class="item-name"><a class="fn" href="fn.load_api.html" title="fn tide_disco::load_api">load_api</a></div><div class="desc docblock-short">Load the web API or panic</div></li><li><div class="item-name"><a class="fn" href="fn.org_data_path.html" title="fn tide_disco::org_data_path">org_data_path</a></div></li><li><div class="item-name"><a class="fn" href="fn.wait_for_server.html" title="fn tide_disco::wait_for_server">wait_for_server</a></div><div class="desc docblock-short">Wait for the server to respond to a connection request</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AppServerState.html" title="type tide_disco::AppServerState">AppServerState</a></div></li><li><div class="item-name"><a class="type" href="type.AppState.html" title="type tide_disco::AppState">AppState</a></div></li><li><div class="item-name"><a class="type" href="type.Html.html" title="type tide_disco::Html">Html</a></div></li></ul></section></div></main></body></html>